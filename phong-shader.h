#include "cocos2d.h"

const GLchar *glslPhongVert = 
"#define MAX_LIGHTS 4																																\n"
"attribute vec3 a_position;																															\n"
"attribute vec2 a_texCoord;																															\n"
"attribute vec3 a_normal;																															\n"
"																																					\n"
"uniform mat4 CC_MMatrix;																															\n"
"uniform mat4 CC_NormalMatrix;																														\n"
"uniform bool uTexture;																																\n"
"uniform vec3 uDiffuse;																																\n"
"uniform vec3 uSpecular;																															\n"
"uniform bool uLightEnabled[MAX_LIGHTS];																											\n"
"uniform vec3 uLightAmbience[MAX_LIGHTS];																											\n"
"uniform vec3 uLightDiffuse[MAX_LIGHTS];																											\n"
"uniform float uLightIntensity[MAX_LIGHTS];																											\n"
"uniform vec3 uLightPosition[MAX_LIGHTS];																											\n"
"																																					\n"
"uniform float alpha;																																\n"
"uniform int mode;																																	\n"
"																																					\n"
"uniform mat4 uShadowProjectionMatrix;																												\n"
"																																					\n"
"varying vec4 v_color;																																\n"
"varying vec4 v_projectorCoord;																														\n"
"varying float v_distance;																															\n"
"																																					\n"
"void main()																																		\n"
"{																																					\n"
"	vec3 defaultAmbience = vec3(0.05);																												\n"
"  																																					\n"
"	// all following gemetric computations are performed in the																						\n"
"	// camera coordinate system (aka eye coordinates)																								\n"
"																																					\n"
"	highp vec3 normal = normalize(vec3(CC_NormalMatrix * vec4(a_normal, 0.0)));																		\n"
"	vec4 vertPos4 = CC_MVMatrix * vec4(a_position, 1.0);																							\n"
"																																					\n"
"	v_distance = vertPos4.z;																														\n"
"																																					\n"
"	highp vec3 frontColor = vec3(0.0);																												\n"
"																																					\n"
"	for (int i = 0; i < MAX_LIGHTS; i++)																											\n"
"	{																																				\n"
"		highp vec3 vertPos = vec3(vertPos4) / vertPos4.w;																							\n"
"		highp vec3 lightDir = normalize(vertPos - uLightPosition[i]);																				\n"
"		highp vec3 reflectDir = reflect(-lightDir, normal);																							\n"
"		highp vec3 viewDir = normalize(vertPos);																									\n"
"		float lambertian = max(dot(lightDir,normal), 0.0);																							\n"
"		float specular = 0.0;																														\n"
"																																					\n"
"		if(lambertian > 0.0)																														\n"
"		{																																			\n"
"			float specAngle = max(dot(reflectDir, viewDir), 0.0);																					\n"
"			specular = pow(specAngle, 4.0);																											\n"
"																																					\n"
"			// the exponent controls the shininess (try mode 2)																						\n"
"			if(mode == 2)  specular = pow(specAngle, 1.0);																							\n"
"																																					\n"
"			// according to the rendering equation we would need to multiply																		\n"
"			// with the the lambertian, but this has little visual effect																			\n"
"																																					\n"
"			if(mode == 3) specular *= lambertian;																									\n"
"																																					\n"
"			// switch to mode 4 to turn off the specular component																					\n"
"																																					\n"
"			if(mode == 4) specular *= 0.0;																											\n"
"		}																																			\n"
"																																					\n"
"		if (uLightEnabled[i])																														\n"
"			frontColor += vec3(defaultAmbience*uLightAmbience[i] + lambertian*uDiffuse*uLightDiffuse[i] + specular*uSpecular) * uLightIntensity[i];	\n"
"	}																																				\n"
"																																					\n"
"	v_color = vec4(frontColor,alpha);																												\n"
"																																					\n"
"	v_projectorCoord = uShadowProjectionMatrix * (CC_MMatrix * vec4(a_position, 1.0));																\n"
"																																					\n"
"	gl_Position = CC_MVPMatrix * vec4(a_position, 1.0);																								\n"
"}";


const GLchar *glslPhongFrag =
"precision mediump float; 												\n"
"varying vec4 v_color;													\n"
"																		\n"
"uniform sampler2D uShadowMap;											\n"
"uniform bool uShadowMapEnabled;										\n"
"																		\n"
"varying vec4 v_projectorCoord;											\n"
"varying float v_distance;												\n"
"																		\n"
"void main() 															\n"
"{																		\n"
"  vec4 projTexColor = vec4(1.0);										\n"
"  vec4 rcoord = v_projectorCoord;										\n"
"																		\n"
#if (CC_TARGET_PLATFORM != CC_PLATFORM_IOS)
"  if (greaterThan(v_projectorCoord, vec4(1.0)).x)						\n"
"     rcoord = vec4(1.0);												\n"
"																		\n"
"  if (lessThan(v_projectorCoord, vec4(0.0)).x)							\n"
"     rcoord = vec4(0.0);												\n"
#endif
"																		\n"
"  projTexColor = texture2DProj(uShadowMap,v_projectorCoord);			\n"
"																		\n"
"  if (projTexColor.r != 1.0 && rcoord.z > 0.0 && uShadowMapEnabled)	\n"
"  {																	\n"
"    projTexColor = v_color * 0.8;										\n"
"	 projTexColor.a = 0.9;												\n"
"  }																	\n"
"  else																	\n"
"  {																	\n"
"    projTexColor = vec4(1.0);											\n"
"  }																	\n"
"																		\n"
"  gl_FragColor = v_color * projTexColor;								\n"
"}																		\n";
